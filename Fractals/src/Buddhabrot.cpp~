#include "Buddhabrot.h"
#include "stdlib.h"
#include "time.h"
using namespace std;

void Buddhabrot::gen_fractal()
{
<<<<<<< HEAD
  
  srand (time(0));
  double MinRe = -2.5;
  double MaxRe = 1.0;
  double MinIm = -1.0;
  double MaxIm = 1.0;
=======
  srand (time(NULL));
  double MinRe = -2.25;
  double MaxRe = 0.75;
  double MinIm = -1.50;
  double MaxIm = 1.50;
>>>>>>> 063a97c3dce74350a8dc2e1f6f668b21ee96a1b9
  int height = get_height();
  int width = get_width();
  double Re_factor = (MaxRe-MinRe)/(width-1);
  double Im_factor = (MaxIm-MinIm)/(height-1);
  int num_pixels = height*width;
  //cout << num_pixels << endl;
  int  outer_array[num_pixels];
  //outer_array = new int[num_pixels];
  for (int bucket = 0; bucket < num_pixels; bucket++)
	  outer_array[bucket] = 0;
<<<<<<< HEAD
  //int * temp_array;
  //temp_array = new int[num_pixels];
  int temp_array[num_pixels];
  for(int i = 0; i < (2*num_pixels); i++)
=======
  int * temp_array;
  temp_array = new int[num_pixels];
  #pragma omp parallel for
  for(int i = 0; i < (10*num_pixels); i++)
>>>>>>> 063a97c3dce74350a8dc2e1f6f668b21ee96a1b9
    {
      for (int bucket = 0; bucket < num_pixels; bucket++)
	{
	  temp_array[bucket] = 0;
	}
      // int temp_bucket[num_pixels];
      int num = rand() % num_pixels;
      //cout << num << endl;
      int x = num%height;
      int y = num/height;
      double c_re = MinRe+x*Re_factor;
      double c_im = MaxIm-y*Im_factor;
      double Z_re = 0;
      double Z_im = 0;
      bool isInside = true;
      for(int iter = 0; iter < MAXITER; iter++)
	{
	  double Z_im2 = Z_im*Z_im;
	  double Z_re2 = Z_re*Z_re;
	  int a = (int)((Z_re-Z_re2+Z_im2-MinRe)/Re_factor);
	  int b = (int)((Z_im-2*Z_re*Z_im-MaxIm)/(-1*Im_factor));
	  if((Z_re2 + Z_im2) > 4)
	    {
	      isInside = false;
	      break;
	    }
	  Z_im = 2*Z_re*Z_im+c_im;
<<<<<<< HEAD
	  Z_re= Z_re2-Z_im2+c_re;
	  temp_array[(a+b)]++;
=======
	  Z_re= Z_re*Z_re-Z_im2+c_re;
	  int array_pos = height * (MaxIm - Z_im) / Im_factor + (Z_re - MinRe) / Re_factor;
	  if (array_pos >= 0 && array_pos < num_pixels)
		temp_array[array_pos]++;
>>>>>>> 063a97c3dce74350a8dc2e1f6f668b21ee96a1b9
	}
      if(isInside == false)
	{
	  for (int pos = 0; pos < num_pixels; pos++)
	    {
	      outer_array[pos] += temp_array[pos];
	    }
	}
    }
<<<<<<< HEAD
  //delete [] temp_array;
  int temp;
=======
  delete [] temp_array;
  double max;
>>>>>>> 063a97c3dce74350a8dc2e1f6f668b21ee96a1b9
  #pragma omp parallel for
  for(int i = 0; i < num_pixels; i++)
    {
      if(i == 0)
	{
	  max = outer_array[0];
	  continue;
	}
      if(outer_array[i] > max)
	{
	  max = outer_array[i];
	}
    }
  #pragma omp parallel for
  for(int i = 0; i < num_pixels; i++)
    {
      outer_array[i] /= temp;
      m_bitmap[i*4] = (int) (outer_array[i]*255);
      m_bitmap[i*4 + 1] = (int) (outer_array[i]*51);
      m_bitmap[i*4 + 2] = (int) (outer_array[i]*51);
      m_bitmap[i*4+3] = 255;
    }
  /*for(int k = 0; k < num_pixels; k++)
    {
<<<<<<< HEAD
      int x = k%height;
      int y = k/height;
      int temp2 = outer_array[k];
      outer_array[k] = temp2/temp;
      m_bitmap[x*height*4 + y*4] = pow( (double(outer_array[k]))/(2*MAXITER),0.60)*255;
      m_bitmap[x*height*4 + y*4 + 1] = pow((double(outer_array[k]))/(2*MAXITER),0.40)*255;
      m_bitmap[x*height*4 + y*4 + 2] = pow((double(outer_array[k]))/(2*MAXITER), 0.30)*255;
      m_bitmap[x*height*4 + y*4 + 3] = 255;
      }*/
  //delete [] outer_array;
=======
      m_bitmap[k*4] = (outer_array[k]/max)*255;
      m_bitmap[k*4 + 1] = (outer_array[k]/max)*255;
      m_bitmap[k*4 + 2] = (outer_array[k]/max)*255;
      m_bitmap[k*4 + 3] = 255;
    }
  delete [] outer_array;
>>>>>>> 063a97c3dce74350a8dc2e1f6f668b21ee96a1b9
}
   
	// Real (-2.5, 1)
	// Imaginary (-1, 1)
    
    // Initialize a bucket array (one integer for each pixel) (this is the outer bucket array)

    // iterate over the following several thousand times (at least more times than # of pixels)
  
        // Create a temporary bucket array (one integer for each pixel
        //
        // Let C be a random point in the complex plane
        //
        // Trace the orbit of C, incrementing the temporary bucket that z falls in for each iteration
        // If Z is in the mandelbrot set, discard the temporary bucket
        // Else, merge the temporary bucket with the outer bucket array
        

     // Normalize the global bucket array by dividing each value by the maximum value
     // Color each pixel however you wish
     //
     // Parallelizing this function is tricky. It helps to have a list of temporary bucket arrays
     // Which are merged after the computation has finished.
     
     // Parallelizing is not required, but will save you a lot of time.
     


    

